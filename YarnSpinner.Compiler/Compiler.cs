namespace Yarn.Compiler
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text.RegularExpressions;
    using Antlr4.Runtime;
    using Antlr4.Runtime.Tree;
    using static Yarn.Instruction.Types;

    internal class StringTableManager
    {
        internal Dictionary<string, StringInfo> StringTable = new Dictionary<string, StringInfo>();

        internal bool ContainsImplicitStringTags
        {
            get
            {
                foreach (var item in StringTable)
                {
                    if (item.Value.isImplicitTag)
                    {
                        return true;
                    }
                }
                return false;
            }
        }

        /// <summary>
        /// Registers a new string in the string table.
        /// </summary>
        /// <param name="text">The text of the string to register.</param>
        /// <param name="nodeName">The name of the node that this string
        /// was found in.</param>
        /// <param name="lineID">The line ID to use for this entry in the
        /// string table.</param>
        /// <param name="lineNumber">The line number that this string was
        /// found in.</param>
        /// <param name="tags">The tags to associate with this string in
        /// the string table.</param>
        /// <returns>The string ID for the newly registered
        /// string.</returns>
        /// <remarks>If <paramref name="lineID"/> is <see
        /// langword="null"/>, a line ID will be generated from <paramref
        /// name="fileName"/>, <paramref name="nodeName"/>, and the number
        /// of elements in <see cref="StringTable"/>.</remarks>
        internal string RegisterString(string text, string fileName, string nodeName, string lineID, int lineNumber, string[] tags)
        {
            string lineIDUsed;

            bool isImplicit;

            if (lineID == null)
            {
                lineIDUsed = $"line:{fileName}-{nodeName}-{this.StringTable.Count}";

                isImplicit = true;
            }
            else
            {
                lineIDUsed = lineID;

                isImplicit = false;
            }

            var theString = new StringInfo(text, fileName, nodeName, lineNumber, isImplicit, tags);

            // Finally, add this to the string table, and return the line
            // ID.
            this.StringTable.Add(lineIDUsed, theString);

            return lineIDUsed;
        }

        internal void Add(IDictionary<string, StringInfo> otherStringTable)
        {
            foreach (var entry in otherStringTable)
            {
                StringTable.Add(entry.Key, entry.Value);
            }
        }
    }

    /// <summary>
    /// Information about a string. Stored inside a string table, which is
    /// produced from the Compiler.
    /// </summary>
    /// <remarks>
    /// You do not create instances of this class yourself. They are
    /// generated by the <see cref="Compiler"/>.
    /// </remarks>
    public struct StringInfo
    {
        /// <summary>
        /// The original text of the string.
        /// </summary>
        public string text;

        /// <summary>
        /// The name of the node that this string was found in.
        /// </summary>
        public string nodeName;

        /// <summary>
        /// The line number at which this string was found in the file.
        /// </summary>
        public int lineNumber;

        /// <summary>
        /// The name of the file this string was found in.
        /// </summary>
        public string fileName;

        /// <summary>
        /// Indicates whether this string's line ID was implicitly
        /// generated.
        /// </summary>
        /// <remarks>
        /// Implicitly generated line IDs are not guaranteed to remain the
        /// same across multiple compilations. To ensure that a line ID
        /// remains the same, you must define it by adding a [line
        /// tag]({{|ref "/docs/unity/localisation.md"|}}) to the line.
        /// </remarks>
        public bool isImplicitTag;

        /// <summary>
        /// The metadata (i.e. hashtags) associated with this string.
        /// </summary>
        /// <remarks>
        /// This array will contain any hashtags associated with this
        /// string besides the `#line:` hashtag.
        /// </remarks>
        public string[] metadata;

        /// <summary>
        /// Initializes a new instance of the <see cref="StringInfo"/>
        /// struct.
        /// </summary>
        /// <param name="text">The text of the string.</param>
        /// <param name="fileName">The file name.</param>
        /// <param name="nodeName">The node name.</param>
        /// <param name="lineNumber">The line number.</param>
        /// <param name="isImplicitTag">If `true`, this string info is
        /// stored with an implicit line ID.</param>
        /// <param name="metadata">The string's metadata.</param>
        internal StringInfo(string text, string fileName, string nodeName, int lineNumber, bool isImplicitTag, string[] metadata)
        {
            this.text = text;
            this.nodeName = nodeName;
            this.lineNumber = lineNumber;
            this.fileName = fileName;
            this.isImplicitTag = isImplicitTag;

            if (metadata != null)
            {
                this.metadata = metadata;
            }
            else
            {
                this.metadata = new string[] { };
            }

        }
    }

    [System.Serializable]
    public class Declaration
    {
        /// <summary>
        /// Gets the name of this Declaration.
        /// </summary>
        public string Name { get => name; internal set => name = value; }

        /// <summary>
        /// Creates a new instance of the <see cref="Declaration"/> class,
        /// using the given <paramref name="name"/> and default value. The
        /// <see cref="ReturnType"/> of the new instance will be configured
        /// based on the type of <paramref name="defaultValue"/>, and the
        /// <see cref="DeclarationType"/> will be <see
        /// cref="Type.Variable"/>. All other properties will be their
        /// default values.
        /// </summary>
        /// <param name="name">The name of the new declaration.</param>
        /// <param name="defaultValue">The default value of the
        /// declaration. This must be a string, a number (integer or
        /// floating-point), or boolean value.</param>
        /// <param name="description">The description of the new
        /// declaration.</param>
        /// <returns>A new instance of the <see cref="Declaration"/>
        /// class.</returns>
        public static Declaration CreateVariable(string name, object defaultValue, string description = null)
        {
            if (defaultValue is null)
            {
                throw new ArgumentNullException(nameof(defaultValue));
            }

            // What type of default value did we get?
            System.Type defaultValueType = defaultValue.GetType();

            // Is it something we can handle?
            if (Value.TypeMappings.ContainsKey(defaultValueType) == false)
            {
                throw new ArgumentException($"Default value type cannot be {defaultValueType}");
            }

            // We're all good to create the new declaration.
            var decl = new Declaration
            {
                Name = name,
                DefaultValue = defaultValue,
                ReturnType = Value.TypeMappings[defaultValueType],
                DeclarationType = Type.Variable,
                Description = description,
            };

            return decl;
        }

        /// <summary>
        /// Gets the default value of this <see cref="Declaration"/>, if no
        /// value has been specified in code or is available from a <see
        /// cref="Dialogue"/>'s <see cref="IVariableStorage"/>.
        /// </summary>
        public object DefaultValue { get => defaultValue; internal set => defaultValue = value; }

        /// <summary>
        /// Gets the type of this declaration.
        /// </summary>
        public Declaration.Type DeclarationType { get => declarationType; internal set => declarationType = value; }

        /// <summary>
        /// Gets the return type of this declaration.
        /// </summary>
        /// <remarks>
        /// For declarations whose <see cref="DeclarationType"/> is <see
        /// cref="Declaration.Type.Variable"/>, this is the type of the
        /// variable.
        /// </remarks>
        public Yarn.Type ReturnType { get => returnType; internal set => returnType = value; }

        /// <summary>
        /// Gets a string describing the purpose of this <see
        /// cref="Declaration"/>.
        /// </summary>
        public string Description { get => description; internal set => description = value; }

        /// <summary>
        /// Gets the <see cref="Parameter"/>s associated with this <see
        /// cref="Declaration"/>.
        /// </summary>
        /// <remarks>
        /// For declarations whose <see cref="DeclarationType"/> is <see
        /// cref="Declaration.Type.Variable"/>, this array will be empty.
        /// </remarks>
        public Parameter[] Parameters { get => parameters; internal set => parameters = value; }
        /// <summary>
        /// Gets the name of the file in which this Declaration was found.
        /// </summary>
        /// <remarks>
        /// If this <see cref="Declaration"/> was not found in a Yarn
        /// source file, this will be <see cref="ExternalDeclaration"/>.
        /// </remarks>
        public string SourceFileName { get => sourceFileName; internal set => sourceFileName = value; }

        /// <summary>
        /// Gets the name of the node in which this Declaration was found.
        /// </summary>
        /// <remarks>
        /// If this <see cref="Declaration"/> was not found in a Yarn
        /// source file, this will be <see langword="null"/>.
        /// </remarks>
        public string SourceNodeName { get => sourceNodeName; internal set => sourceNodeName = value; }

        /// <summary>
        /// The line number at which this Declaration was found in the
        /// source file.
        /// </summary>
        /// <remarks>
        /// If this <see cref="Declaration"/> was not found in a Yarn
        /// source file, this will be -1.
        /// </remarks>
        public int SourceFileLine { get => sourceFileLine; internal set => sourceFileLine = value; }

        /// <summary>
        /// Gets the line number at which this Declaration was found in the node
        /// indicated by <see cref="SourceNodeName"/>.
        /// </summary>
        /// <remarks>
        /// If this <see cref="Declaration"/> was not found in a Yarn
        /// source file, this will be -1.
        /// </remarks>
        public int SourceNodeLine { get => sourceNodeLine; internal set => sourceNodeLine = value; }

        /// <summary>
        /// Get or sets a value indicating whether this Declaration was implicitly
        /// inferred from usage.
        /// </summary>
        /// <value>If <see langword="true"/>, this Declaration was
        /// implicitly inferred from usage. If <see langword="false"/>,
        /// this Declaration appears in the source code.</value>
        public bool IsImplicit { get; internal set; }

        /// <summary>
        /// The string used for <see cref="SourceFileName"/> if the
        /// Declaration was found outside of a Yarn source file.
        /// </summary>
        public const string ExternalDeclaration = "(External)";

        internal string name;
        internal object defaultValue;
        internal Type declarationType = Declaration.Type.Variable;
        internal Yarn.Type returnType;
        internal string description;
        internal Parameter[] parameters = new Parameter[0];
        internal string sourceFileName;
        internal string sourceNodeName;
        internal int sourceFileLine;
        internal int sourceNodeLine;

        public Declaration()
        {
        }

        /// <summary>
        /// Enumerates the different types of <see cref="Declaration"/>
        /// structs that may be encountered.
        /// </summary>
        public enum Type
        {
            /// <summary>
            /// Variables have a return type, have no parameters, and can be assigned to.
            /// </summary>
            Variable,

            /// <summary>
            /// Functions has a return type, may have parameters, and cannot be assigned to.
            /// </summary>
            Function,
        }

        /// <summary>
        /// A parameter for a function <see cref="Declaration"/>.
        /// </summary>
        [System.Serializable]
        public class Parameter
        {
            private string name;
            private Yarn.Type type;

            public string Name { get => name; internal set => name = value; }

            public Yarn.Type Type { get => type; internal set => type = value; }

            // override object.Equals
            public override bool Equals(object obj)
            {
                if (obj == null || !(obj is Parameter otherParam))
                {
                    return false;
                }

                return this.Name == otherParam.Name &&
                    this.Type == otherParam.Type;
            }

            // override object.GetHashCode
            public override int GetHashCode()
            {
                return Name.GetHashCode() ^ Type.GetHashCode();
            }
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            string result;
            switch (this.DeclarationType)
            {
                case Type.Variable:
                    result = $"{Name} : {ReturnType} = {DefaultValue}";
                    break;
                case Type.Function:
                    result = $"{Name} : ({string.Join(", ", (object[])Parameters)}) -> {ReturnType}";
                    break;
                default:
                    throw new InvalidOperationException($"Invalid declaration type {this.DeclarationType}");
            }
            if (string.IsNullOrEmpty(Description))
            {
                return result;
            }
            else
            {
                return result + $" (\"{Description}\")";
            }
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj == null || !(obj is Declaration otherDecl))
            {
                return false;
            }

            if (Parameters.Length != otherDecl.Parameters.Length)
            {
                return false;
            }

            for (int i = 0; i < Parameters.Length; i++)
            {
                Parameter myParam = Parameters[i];
                Parameter theirParam = otherDecl.Parameters[i];

                if (myParam.Equals(theirParam) == false)
                {
                    return false;
                }
            }

            return this.Name == otherDecl.Name &&
                this.ReturnType == otherDecl.ReturnType &&
                this.DefaultValue == otherDecl.DefaultValue &&
                this.Description == otherDecl.Description &&
                this.DeclarationType == otherDecl.DeclarationType;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int paramsHash = 0;
            foreach (var param in Parameters)
            {
                if (paramsHash == 0)
                {
                    paramsHash = param.GetHashCode();
                }
                else
                {
                    paramsHash ^= param.GetHashCode();
                }
            }
            return this.Name.GetHashCode()
                ^ this.ReturnType.GetHashCode()
                ^ this.DeclarationType.GetHashCode()
                ^ this.DefaultValue.GetHashCode()
                ^ paramsHash
                ^ (this.Description ?? string.Empty).GetHashCode();
        }
    }

    public struct CompilationJob
    {

        /// <summary>
        /// Represents the contents of a file to compile.
        /// </summary>
        public struct File
        {
            public string FileName;
            public string Source;
        }

        public enum Type
        {
            /// <summary>The compiler will do a full compilation, and
            /// generate a <see cref="Program"/>, function declaration set,
            /// and string table.</summary>
            FullCompilation,

            /// <summary>The compiler will derive only the variable and
            /// function declarations, and file tags, found in the
            /// script.</summary>
            DeclarationsOnly,

            /// <summary>The compiler will generate a string table
            /// only.</summary>
            StringsOnly,
        }

        /// <summary>
        /// The <see cref="File"/> structs that represent the content to
        /// parse..
        /// </summary>
        public IEnumerable<File> Files;

        /// <summary>
        /// The <see cref="Library"/> that contains declarations for
        /// functions.
        /// </summary>
        public Library Library;

        /// <summary>
        /// The type of compilation to perform.
        /// </summary>
        public Type CompilationType;

        /// <summary>
        /// The declarations for variables.
        /// </summary>
        public IEnumerable<Declaration> VariableDeclarations;

        /// <summary>
        /// Creates a new <see cref="CompilationJob"/> using the contents
        /// of a collection of files.
        /// </summary>
        /// <param name="paths">The paths to the files.</param>
        /// <returns>A new <see cref="CompilationJob"/>.</returns>
        public static CompilationJob CreateFromFiles(IEnumerable<string> paths, Library library = null)
        {
            var fileList = new List<File>();

            // Read every file and add it to the file list
            foreach (var path in paths)
            {
                fileList.Add(new File
                {
                    FileName = path,
                    Source = System.IO.File.ReadAllText(path),
                });
            }

            return new CompilationJob
            {
                Files = fileList.ToArray(),
                Library = library,
            };
        }

        public static CompilationJob CreateFromFiles(params string[] paths)
        {
            return CreateFromFiles((IEnumerable<string>)paths);
        }

        /// <summary>
        /// Creates a new <see cref="CompilationJob"/> using the contents
        /// of a string.
        /// </summary>
        /// <param name="fileName">The name to assign to the compiled
        /// file.</param>
        /// <param name="source">The text to compile.</param>
        /// <returns>A new <see cref="CompilationJob"/>.</returns>
        public static CompilationJob CreateFromString(string fileName, string source, Library library = null)
        {
            return new CompilationJob
            {
                Files = new List<File>
                {
                    new File {
                        Source = source, FileName = fileName
                    },
                },
                Library = library,
            };
        }
    }

    public struct CompilationResult
    {
        public Program Program { get; internal set; }

        public IDictionary<string, StringInfo> StringTable { get; internal set; }

        public IEnumerable<Declaration> Declarations { get; internal set; }

        public bool ContainsImplicitStringTags { get; internal set; }

        public Dictionary<string, IEnumerable<string>> FileTags { get; internal set; }

        internal static CompilationResult CombineCompilationResults(IEnumerable<CompilationResult> results, StringTableManager stringTableManager)
        {
            CompilationResult finalResult;

            var programs = new List<Program>();
            var declarations = new List<Declaration>();
            var tags = new Dictionary<string, IEnumerable<string>>();

            foreach (var result in results)
            {
                programs.Add(result.Program);

                if (result.Declarations != null)
                {
                    declarations.AddRange(result.Declarations);
                }

                if (result.FileTags != null)
                {
                    foreach (var kvp in result.FileTags)
                    {
                        tags.Add(kvp.Key, kvp.Value);
                    }
                }

            }

            return new CompilationResult
            {
                Program = Program.Combine(programs.ToArray()),
                StringTable = stringTableManager.StringTable,
                Declarations = declarations,
                ContainsImplicitStringTags = stringTableManager.ContainsImplicitStringTags,
                FileTags = tags,
            };
        }
    }

    /// <summary>
    /// Compiles Yarn code.
    /// </summary>
    public class Compiler : YarnSpinnerParserBaseListener
    {
        /// <summary>A regular expression used to detect illegal characters
        /// in node titles.</summary>
        private readonly Regex invalidNodeTitleNameRegex = new Regex(@"[\[<>\]{}\|:\s#\$]");

        private int labelCount = 0;

        /// <summary>
        /// Gets the current node to which instructions are being added.
        /// </summary>
        /// <value>The current node.</value>
        internal Node CurrentNode { get; private set; }

        /// <summary>
        /// Gets whether we are currently parsing the current node as a
        /// 'raw text' node, or as a fully syntactic node.
        /// </summary>
        /// <value>Whether this is a raw text node or not.</value>
        internal bool RawTextNode { get; set; } = false;

        /// <summary>
        /// Gets the program being generated by the compiler.
        /// </summary>
        internal Program Program { get; private set; }

        /// <summary>
        /// The name of the file we are currently parsing from.
        /// </summary>
        private readonly string fileName;

        /// <summary>
        /// The list of variable declarations known to the compiler.
        /// Supplied as part of a <see cref="CompilationJob"/>, or by <see
        /// cref="GetDeclarations"/>
        /// </summary>
        internal IEnumerable<Declaration> VariableDeclarations = new List<Declaration>();

        /// <summary>
        /// The Library, which contains the function declarations known to
        /// the compiler. Supplied as part of a <see
        /// cref="CompilationJob"/>.
        /// </summary>
        internal Library Library { get; private set; }

        internal Compiler(string fileName)
        {
            Program = new Program();
            this.fileName = fileName;
        }

#if DEBUG
        internal string parseTree;
        internal List<string> tokens;
#endif

        public static CompilationResult Compile(CompilationJob compilationJob)
        {
            var results = new List<CompilationResult>();

            // All variable declarations that we've encountered during this
            // compilation job
            var derivedVariableDeclarations = new List<Declaration>();

            // All variable declarations that we've encountered, PLUS the
            // ones we knew about before
            var knownVariableDeclarations = new List<Declaration>();
            if (compilationJob.VariableDeclarations != null)
            {
                knownVariableDeclarations.AddRange(compilationJob.VariableDeclarations);
            }

            // Get function declarations from the library, if provided
            if (compilationJob.Library != null)
            {
                knownVariableDeclarations.AddRange(GetDeclarationsFromLibrary(compilationJob.Library));
            }

            var compiledTrees = new List<(string name, IParseTree tree)>();

            // First pass: parse all files, generate their syntax trees,
            // and figure out what variables they've declared
            var stringTableManager = new StringTableManager();

            foreach (var file in compilationJob.Files)
            {
                var tree = ParseSyntaxTree(file);
                compiledTrees.Add((file.FileName, tree));

                RegisterStrings(file.FileName, stringTableManager, tree);
            }

            if (compilationJob.CompilationType == CompilationJob.Type.StringsOnly)
            {
                // Stop at this point
                return new CompilationResult
                {
                    Declarations = null,
                    ContainsImplicitStringTags = stringTableManager.ContainsImplicitStringTags,
                    Program = null,
                    StringTable = stringTableManager.StringTable,
                };
            }

            var fileTags = new Dictionary<string, IEnumerable<string>>();

            foreach (var parsedFile in compiledTrees)
            {
                GetDeclarations(parsedFile.name, parsedFile.tree, knownVariableDeclarations, out var newDeclarations, out var newFileTags);

                derivedVariableDeclarations.AddRange(newDeclarations);
                knownVariableDeclarations.AddRange(newDeclarations);

                fileTags.Add(parsedFile.name, newFileTags);
            }

            foreach (var parsedFile in compiledTrees) {
                var checker = new TypeCheckVisitor(parsedFile.name, knownVariableDeclarations);

                checker.Visit(parsedFile.tree);
                derivedVariableDeclarations.AddRange(checker.NewDeclarations);
                knownVariableDeclarations.AddRange(checker.NewDeclarations);
            }

            if (compilationJob.CompilationType == CompilationJob.Type.DeclarationsOnly)
            {
                // Stop at this point
                return new CompilationResult
                {
                    Declarations = derivedVariableDeclarations,
                    ContainsImplicitStringTags = false,
                    Program = null,
                    StringTable = null,
                    FileTags = fileTags,
                };
            }

            foreach (var parsedFile in compiledTrees)
            {
                CompilationResult compilationResult = GenerateCode(parsedFile.name, knownVariableDeclarations, compilationJob, parsedFile.tree, stringTableManager);
                results.Add(compilationResult);
            }

            var finalResult = CompilationResult.CombineCompilationResults(results, stringTableManager);

            // Last step: take every variable declaration we found in all
            // of the inputs, and create an initial value registration for
            // it. 
            foreach (var declaration in knownVariableDeclarations)
            {
                // We only care about variable declarations here
                if (declaration.DeclarationType != Declaration.Type.Variable)
                {
                    continue;
                }

                Operand value;

                if (declaration.DeclarationType == Declaration.Type.Variable && declaration.defaultValue == null)
                {
                    throw new NullReferenceException($"Variable declaration {declaration.name} ({declaration.ReturnType}) has a null default value. This is not allowed.");
                }

                switch (declaration.ReturnType)
                {
                    case Yarn.Type.Number:
                        value = new Operand(Convert.ToSingle(declaration.DefaultValue));
                        break;
                    case Yarn.Type.String:
                        value = new Operand(Convert.ToString(declaration.DefaultValue));
                        break;
                    case Yarn.Type.Bool:
                        value = new Operand(Convert.ToBoolean(declaration.DefaultValue));
                        break;
                    default:
                        throw new ArgumentOutOfRangeException($"Cannot create an initial value for type {declaration.ReturnType}");
                }

                finalResult.Program.InitialValues.Add(declaration.Name, value);
            }

            finalResult.Declarations = derivedVariableDeclarations;

            finalResult.FileTags = fileTags;

            return finalResult;
        }

        private static void RegisterStrings(string fileName, StringTableManager stringTableManager, IParseTree tree)
        {
            var visitor = new StringTableGeneratorVisitor(fileName, stringTableManager);
            visitor.Visit(tree);
        }

        private static void GetDeclarations(string sourceFileName, IParseTree tree, IEnumerable<Declaration> existingDeclarations, out IEnumerable<Declaration> newDeclarations, out IEnumerable<string> fileTags)
        {
            var variableDeclarationVisitor = new DeclarationVisitor(sourceFileName, existingDeclarations);

            try
            {
                variableDeclarationVisitor.Visit(tree);
            }
            catch (TypeException e)
            {
                throw new TypeException(e.Context, e.InternalMessage, sourceFileName);
            }

            // Upon exit, newDeclarations will now contain every variable
            // declaration we found
            newDeclarations = variableDeclarationVisitor.NewDeclarations;

            fileTags = variableDeclarationVisitor.FileTags;
        }

        private static CompilationResult GenerateCode(string fileName, IEnumerable<Declaration> variableDeclarations, CompilationJob job, IParseTree tree, StringTableManager stringTableManager)
        {
            Compiler compiler = new Compiler(fileName);

            compiler.Library = job.Library;
            compiler.VariableDeclarations = variableDeclarations;

            try
            {
                compiler.Compile(tree);
            }
            catch (TypeException e)
            {
                throw new TypeException(e.Context, e.InternalMessage, fileName);
            }

            return new CompilationResult
            {
                Program = compiler.Program,
                StringTable = stringTableManager.StringTable,
                ContainsImplicitStringTags = stringTableManager.ContainsImplicitStringTags,
            };
        }

        /// <summary>
        /// Returns a collection of <see cref="Declaration"/> structs that
        /// describe the functions present in <paramref name="library"/>.
        /// </summary>
        /// <param name="library">The <see cref="Library"/> to get
        /// declarations from.</param>
        /// <returns>The <see cref="Declaration"/> structs found.</returns>
        /// <throws cref="TypeException">Thrown when a function in
        /// <paramref name="library"/> has an invalid return type, an
        /// invalid parameter type, an optional parameter, or an out
        /// parameter.</throws>
        internal static IEnumerable<Declaration> GetDeclarationsFromLibrary(Library library)
        {
            var declarations = new List<Declaration>();

            foreach (var function in library.Delegates)
            {
                var method = function.Value.Method;

                if (method.ReturnType == typeof(Value))
                {
                    // Functions that return the internal type Values are
                    // operators, and are type checked by
                    // ExpressionTypeVisitor. (Future work: define each
                    // polymorph of each operator as a separate function
                    // that returns a concrete type, rather than the
                    // current method of having a 'Value' wrapper type).
                    continue;
                }

                if (Value.TypeMappings.TryGetValue(method.ReturnType, out var yarnReturnType) == false)
                {
                    throw new TypeException($"Function {function.Key} cannot be used in Yarn Spinner scripts: {method.ReturnType} is not a valid return type.");
                }

                var parameters = new List<Declaration.Parameter>();

                bool includeMethod = true;

                foreach (var paramInfo in method.GetParameters())
                {
                    if (paramInfo.ParameterType == typeof(Value))
                    {
                        // Don't type-check this method - it's an operator
                        includeMethod = false;
                        break;
                    }

                    if (paramInfo.IsOptional)
                    {
                        throw new TypeException($"Function {function.Key} cannot be used in Yarn Spinner scripts: parameter {paramInfo.Name} is optional, which isn't supported.");
                    }

                    if (paramInfo.IsOut)
                    {
                        throw new TypeException($"Function {function.Key} cannot be used in Yarn Spinner scripts: parameter {paramInfo.Name} is an out parameter, which isn't supported.");
                    }

                    if (Value.TypeMappings.TryGetValue(paramInfo.ParameterType, out var yarnParameterType) == false)
                    {
                        throw new TypeException($"Function {function.Key} cannot be used in Yarn Spinner scripts: parameter {paramInfo.Name}'s type ({paramInfo.ParameterType}) cannot be used.");
                    }

                    var parameter = new Declaration.Parameter
                    {
                        Name = paramInfo.Name,
                        Type = yarnParameterType,
                    };

                    parameters.Add(parameter);
                }

                if (includeMethod == false)
                {
                    continue;
                }

                var declaration = new Declaration
                {
                    DeclarationType = Declaration.Type.Function,
                    Name = function.Key,
                    ReturnType = yarnReturnType,
                    Parameters = parameters.ToArray(),
                    SourceFileLine = -1,
                    SourceNodeLine = -1,
                    SourceFileName = Declaration.ExternalDeclaration,
                    SourceNodeName = null,
                };

                declarations.Add(declaration);
            }

            return declarations;
        }

        private static IParseTree ParseSyntaxTree(CompilationJob.File file)
        {
            ICharStream input = CharStreams.fromstring(file.Source);

            YarnSpinnerLexer lexer = new YarnSpinnerLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lexer);

            YarnSpinnerParser parser = new YarnSpinnerParser(tokens);

            // turning off the normal error listener and using ours
            parser.RemoveErrorListeners();
            parser.AddErrorListener(ParserErrorListener.Instance);

            lexer.RemoveErrorListeners();
            lexer.AddErrorListener(LexerErrorListener.Instance);

            IParseTree tree;
            try
            {
                tree = parser.dialogue();
            }
            catch (ParseException e)
            {
#if DEBUG
                var tokenStringList = new List<string>();
                tokens.Reset();
                foreach (var token in tokens.GetTokens())
                {
                    tokenStringList.Add($"{token.Line}:{token.Column} {YarnSpinnerLexer.DefaultVocabulary.GetDisplayName(token.Type)} \"{token.Text}\"");
                }

                throw new ParseException(e.Context, $"{e.Message}\n\nTokens:\n{string.Join("\n", tokenStringList)}", file.FileName);
#else
                throw new ParseException(e.Context, e.Message, file.FileName);
#endif // DEBUG
            }

            return tree;
        }

        /// <summary>
        /// Lexes a string containing source code, and returns a list of
        /// tokens found in the source code.
        /// </summary>
        /// <param name="path">The path of the file containing source code
        /// to extract tokens from.</param>
        /// <returns>The list of tokens extracted from the source
        /// code.</returns>
        internal static List<string> GetTokensFromFile(string path)
        {
            var text = File.ReadAllText(path);
            return GetTokensFromString(text);
        }

        /// <summary>
        /// Lexes a string containing source code, and returns a list of
        /// tokens found in the source code.
        /// </summary>
        /// <param name="text">The source code to extract tokens
        /// from.</param>
        /// <returns>The list of tokens extracted from the source
        /// code.</returns>
        internal static List<string> GetTokensFromString(string text)
        {
            ICharStream input = CharStreams.fromstring(text);

            YarnSpinnerLexer lexer = new YarnSpinnerLexer(input);

            var tokenStringList = new List<string>();

            var tokens = lexer.GetAllTokens();
            foreach (var token in tokens)
            {
                tokenStringList.Add($"{token.Line}:{token.Column} {YarnSpinnerLexer.DefaultVocabulary.GetDisplayName(token.Type)} \"{token.Text}\"");
            }

            return tokenStringList;
        }

        /// <summary>
        /// Generates a unique label name to use in the program.
        /// </summary>
        /// <param name="commentary">Any additional text to append to the
        /// end of the label.</param>
        /// <returns>The new label name.</returns>
        internal string RegisterLabel(string commentary = null)
        {
            return "L" + labelCount++ + commentary;
        }

        /// <summary>
        /// Creates a new instruction, and appends it to a node in the <see
        /// cref="Program" />.
        /// </summary>
        /// <param name="node">The node to append instructions to.</param>
        /// <param name="code">The opcode of the instruction.</param>
        /// <param name="operands">The operands to associate with the
        /// instruction.</param>
        void Emit(Node node, OpCode code, params Operand[] operands)
        {
            var instruction = new Instruction
            {
                Opcode = code
            };

            instruction.Operands.Add(operands);

            node.Instructions.Add(instruction);
        }

        /// <summary>
        /// Creates a new instruction, and appends it to the current node
        /// in the <see cref="Program"/>. Called by instances of <see
        /// cref="CodeGenerationVisitor"/> while walking the parse tree.
        /// </summary>
        /// <param name="code">The opcode of the instruction.</param>
        /// <param name="operands">The operands to associate with the
        /// instruction.</param>
        internal void Emit(OpCode code, params Operand[] operands)
        {
            Emit(this.CurrentNode, code, operands);
        }

        /// <summary>
        /// Extracts a line ID from a collection of <see
        /// cref="YarnSpinnerParser.HashtagContext"/>s, if one exists.
        /// </summary>
        /// <param name="hashtagContexts">The hashtag parsing contexts.</param>
        /// <returns>The line ID if one is present in the hashtag contexts,
        /// otherwise `null`.</returns>
        internal static string GetLineID(YarnSpinnerParser.HashtagContext[] hashtagContexts)
        {
            // if there are any hashtags
            if (hashtagContexts != null)
            {
                foreach (var hashtagContext in hashtagContexts)
                {
                    string tagText = hashtagContext.text.Text;
                    if (tagText.StartsWith("line:", StringComparison.InvariantCulture))
                    {
                        return tagText;
                    }
                }
            }

            return null;
        }

        // this replaces the CompileNode from the old compiler will start
        // walking the parse tree emitting byte code as it goes along this
        // will all get stored into our program var needs a tree to walk,
        // this comes from the ANTLR Parser/Lexer steps
        internal void Compile(IParseTree tree)
        {
            ParseTreeWalker walker = new ParseTreeWalker();
            walker.Walk(this, tree);
        }

        // we have found a new node set up the currentNode var ready to
        // hold it and otherwise continue
        public override void EnterNode(YarnSpinnerParser.NodeContext context)
        {
            CurrentNode = new Node();
            RawTextNode = false;
        }

        // have left the current node store it into the program wipe the
        // var and make it ready to go again
        public override void ExitNode(YarnSpinnerParser.NodeContext context)
        {
            Program.Nodes[CurrentNode.Name] = CurrentNode;
            CurrentNode = null;
            RawTextNode = false;
        }

        // have finished with the header so about to enter the node body
        // and all its statements do the initial setup required before
        // compiling that body statements eg emit a new startlabel
        public override void ExitHeader(YarnSpinnerParser.HeaderContext context)
        {
            var headerKey = context.header_key.Text;

            // Use the header value if provided, else fall back to the
            // empty string. This means that a header like "foo: \n" will
            // be stored as 'foo', '', consistent with how it was typed.
            // That is, it's not null, because a header was provided, but
            // it was written as an empty line.
            var headerValue = context.header_value?.Text ?? "";

            if (headerKey.Equals("title", StringComparison.InvariantCulture))
            {
                // Set the name of the node
                CurrentNode.Name = headerValue;

                // Throw an exception if this node name contains illegal
                // characters
                if (invalidNodeTitleNameRegex.IsMatch(CurrentNode.Name))
                {
                    throw new ParseException(context, $"The node '{CurrentNode.Name}' contains illegal characters in its title.");
                }
            }

            if (headerKey.Equals("tags", StringComparison.InvariantCulture))
            {
                // Split the list of tags by spaces, and use that
                var tags = headerValue.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                CurrentNode.Tags.Add(tags);

                if (CurrentNode.Tags.Contains("rawText"))
                {
                    // This is a raw text node. Flag it as such for future
                    // compilation.
                    RawTextNode = true;
                }
            }
        }

        // have entered the body the header should have finished being
        // parsed and currentNode ready all we do is set up a body visitor
        // and tell it to run through all the statements it handles
        // everything from that point onwards
        public override void EnterBody(YarnSpinnerParser.BodyContext context)
        {
            // if it is a regular node
            if (!RawTextNode)
            {
                // This is the start of a node that we can jump to. Add a
                // label at this point.
                CurrentNode.Labels.Add(RegisterLabel(), CurrentNode.Instructions.Count);

                CodeGenerationVisitor visitor = new CodeGenerationVisitor(this);

                foreach (var statement in context.statement())
                {
                    visitor.Visit(statement);
                }
            }
            // We are a rawText node. Don't compile it; instead, note the string
            else
            {
                CurrentNode.SourceTextStringID = Compiler.GetLineIDForNodeName(CurrentNode.Name);
            }
        }

        public static string GetLineIDForNodeName(string name)
        {
            return "line:" + name;
        }

        // exiting the body of the node, time for last minute work before
        // moving onto the next node Does this node end after emitting
        // AddOptions codes without calling ShowOptions?
        public override void ExitBody(YarnSpinnerParser.BodyContext context)
        {
            // Note: this only works when we know that we don't have
            // AddOptions and then Jump up back into the code to run
            // them. TODO: A better solution would be for the parser to
            // flag whether a node has Options at the end.
            var hasRemainingOptions = false;
            foreach (var instruction in CurrentNode.Instructions)
            {
                if (instruction.Opcode == OpCode.AddOption)
                {
                    hasRemainingOptions = true;
                }
                if (instruction.Opcode == OpCode.ShowOptions)
                {
                    hasRemainingOptions = false;
                }
            }

            // If this compiled node has no lingering options to show
            // at the end of the node, then stop at the end
            if (hasRemainingOptions == false)
            {
                Emit(CurrentNode, OpCode.Stop);
            }
            else
            {
                // Otherwise, show the accumulated nodes and then jump
                // to the selected node
                Emit(CurrentNode, OpCode.ShowOptions);

                // Showing options will make the execution stop; the
                // user will have invoked code that pushes the name of
                // a node onto the stack, which RunNode handles
                Emit(CurrentNode, OpCode.RunNode);
            }
        }
    }
}
